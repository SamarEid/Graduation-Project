/*
 * ultraSonic.c
 *
 *  Created on: ??þ/??þ/????
 *      Author: ASHRY
 */
#include "../../../Libraries/Device/STM32F4xx/Include/stm32f4xx.h"
#include "../../../Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_gpio.h"
#include "../../../Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_tim.h"
#include "../../utils/utils.h"
#include "ultraSonic.h"

void ultraSonicVidInit(ultraSonicInitTypeDef* ultraSonicSensor) {
    // Variables declaration
    GPIO_InitTypeDef gpioPinInitStructure;
    TIM_TimeBaseInitTypeDef timerBaseInitStructure;
    TIM_OCInitTypeDef triggerTimerOCInitStruct;
    TIM_ICInitTypeDef TIM_ICInitStruct;
    static void(*TIMOCFunctions[])(TIM_TypeDef*, TIM_OCInitTypeDef*) = {TIM_OC1Init,TIM_OC2Init,TIM_OC3Init,TIM_OC4Init};
    //trigger using PWM
    // Init GPIO PIN for trigger Timer Alternate function
    gpioPinInitStructure.GPIO_Pin = ultraSonicSensor->GPIOxTriggerPin;
    gpioPinInitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    gpioPinInitStructure.GPIO_Mode = GPIO_Mode_AF;
    gpioPinInitStructure.GPIO_OType = GPIO_OType_PP;
    gpioPinInitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    GPIO_Init(ultraSonicSensor->GPIOxTrigger, &gpioPinInitStructure);
    // Configure Alternate Function for Trigger Pin
    GPIO_PinAFConfig(ultraSonicSensor->GPIOxTrigger, PinSource(ultraSonicSensor->GPIOxTriggerPin), ultraSonicSensor->GPIOxTriggerPinAF);
    // Timer Base Configuration for trigger signal
    timerBaseInitStructure.TIM_Period = GET_RESET_VALUE();
    timerBaseInitStructure.TIM_Prescaler = GET_PSC();
    timerBaseInitStructure.TIM_ClockDivision = CLOCK_DIVISON;
    timerBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseInit(ultraSonicSensor->TIMxTrigger, &timerBaseInitStructure);
    // Timer Output Compare for PWM
    triggerTimerOCInitStruct.TIM_OCMode = TIM_OCMode_PWM1;
    triggerTimerOCInitStruct.TIM_OCPolarity = TIM_OCPolarity_High;
    triggerTimerOCInitStruct.TIM_OutputState = TIM_OutputState_Enable;
    triggerTimerOCInitStruct.TIM_Pulse = GET_ARR();
    TIMOCFunctions[GET_OC_INDEX(ultraSonicSensor->TIMxTrigger_Channel)](ultraSonicSensor->TIMxTrigger, &triggerTimerOCInitStruct);
	//Init GPIO PIN for Echo Timer Alternate function
    gpioPinInitStructure.GPIO_Pin = ultraSonicSensor->GPIOxEchoPin;
    GPIO_Init(ultraSonicSensor->GPIOxEcho, &gpioPinInitStructure);
    // Configure Alternate Function for Echo Pin
    GPIO_PinAFConfig(ultraSonicSensor->GPIOxEcho, PinSource(ultraSonicSensor->GPIOxEchoPin), ultraSonicSensor->GPIOxEchoPinAF);
    // init basic timer for Input capture unit
    TIM_TimeBaseInit(ultraSonicSensor->TIMxEcho, &timerBaseInitStructure);
    //Configure TIM Channel for Input Capture
    TIM_ICInitStruct.TIM_Channel = ECHO_CHANNEL;
    TIM_ICInitStruct.TIM_ICPolarity = TIM_ICPolarity_BothEdge;
    TIM_ICInitStruct.TIM_ICSelection = TIM_ICSelection_DirectTI;
    TIM_ICInitStruct.TIM_ICPrescaler = CLOCK_DIVISON;
    TIM_ICInitStruct.TIM_ICFilter = DIGITAL_FILTER;
    TIM_ICInit(ultraSonicSensor->TIMxEcho, &TIM_ICInitStruct);
    //enable interrupt for echo timer
    TIM_ITConfig(ultraSonicSensor->TIMxEcho, TIM_IT_Update, ENABLE);
    TIM_ITConfig(ultraSonicSensor->TIMxEcho, IT_CC_CHANNEL , ENABLE);
	NVIC_EnableIRQ(ultraSonicSensor->EchoIRQ);
}
void ultraSonicVidStart(ultraSonicInitTypeDef* ultraSonicSensor) {
    //Enable Trigger Timer
    TIM_Cmd(ultraSonicSensor->TIMxTrigger, ENABLE);
    //Enable Echo Timer
    TIM_Cmd(ultraSonicSensor->TIMxEcho, ENABLE);
}
float ultraSonicFloatGetDistance(uint32_t*firstICVal,uint32_t*secondICVal){
	uint32_t difference = 0;
	float distance = 0.00;
	difference = (*secondICVal) - (*firstICVal);
	distance = ((SOUND_SPEED)*(difference*(1/TICK_FREQUENCY)))/2; // in meters
	return distance;
}

void ultraSonicInputCaptureHandler(TIM_TypeDef*TIMx,uint32_t*firstICVal,uint32_t*secondICVal,float*distance,uint8_t* flag){
    if (TIM_GetITStatus(TIMx, TIM_IT_Update) != RESET)
    {
		TIM_ClearITPendingBit(TIMx ,TIM_IT_Update);
		*flag = FIRST_CAPTURE;
    }
	if(TIM_GetITStatus(TIMx,IT_CC_CHANNEL)!= RESET){
		TIM_ClearITPendingBit(TIMx , IT_CC_CHANNEL);
		uint32_t capturedValue = TIM_GetCapture1(TIMx);
		switch(*flag){
			case FIRST_CAPTURE :
				*firstICVal = capturedValue;
				*flag = SECOND_CAPTURE;
				break;
			case SECOND_CAPTURE :
				*secondICVal = capturedValue;
				*flag = FIRST_CAPTURE;
				*distance = ultraSonicFloatGetDistance(firstICVal,secondICVal);
				GPIO_ToggleBits(GPIOA, GPIO_Pin_5);
				//reset captures
				*firstICVal = 0;
				*secondICVal = 0;
				break;
			default :
				break;
		}
	}

}
