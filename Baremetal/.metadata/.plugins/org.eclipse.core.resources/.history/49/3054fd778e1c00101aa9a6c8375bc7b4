/*
 * app.c
 *
 *  Created on: ??þ/??þ/????
 *      Author: ASHRY
 */
#include "stm32f4xx_hal.h"
#include "cmsis_os.h"
#include "../HAL/ultraSonic/ultraSonic.h"
#include "../../communication/communication.h"
#include "../../communication/sender/typesdefinition/typedefinitions.h"
#include "../../communication/sender/transmission/transmission.h"
#include "./app.h"

// define timer handlers
TIM_HandleTypeDef htim2 = {0};
TIM_HandleTypeDef htim3 = {0};
TIM_HandleTypeDef htim4 = {0};
TIM_HandleTypeDef htim5 = {0};
// ultraSonic structs to initialize sensors to its pins and timers
ultraSonicInitTypeDef FRONT_ultraSonic = {
		.GPIOxTrigger = GPIOA,
		.GPIOxEcho = GPIOA,
		.GPIOxTriggerPin = GPIO_PIN_3,
		.GPIOxEchoPin = GPIO_PIN_6,
		.GPIOxTriggerPinAF = GPIO_AF1_TIM2,
		.GPIOxEchoPinAF = GPIO_AF2_TIM3,
		.TIMxTrigger = TIM2,
		.TIMxEcho = TIM3,
		.htimTrigger = &htim2,
		.htimEcho = &htim3,
		.TIMxTrigger_Channel = TIM_CHANNEL_4,
		.EchoIRQ = TIM3_IRQn,
};

ultraSonicInitTypeDef LHS_ultraSonic = {
		.GPIOxTrigger = GPIOB,
		.GPIOxEcho = GPIOB,
		.GPIOxTriggerPin = GPIO_PIN_3,
		.GPIOxEchoPin = GPIO_PIN_6,
		.GPIOxTriggerPinAF = GPIO_AF1_TIM2,
		.GPIOxEchoPinAF = GPIO_AF2_TIM4,
		.TIMxTrigger = TIM2,
		.TIMxEcho = TIM4,
		.htimTrigger = &htim2,
		.htimEcho = &htim4,
		.TIMxTrigger_Channel = TIM_CHANNEL_2,
		.EchoIRQ = TIM4_IRQn,
};

ultraSonicInitTypeDef RHS_ultraSonic = {
		.GPIOxTrigger = GPIOB,
		.GPIOxEcho = GPIOA,
		.GPIOxTriggerPin = GPIO_PIN_10,
		.GPIOxEchoPin = GPIO_PIN_0,
		.GPIOxTriggerPinAF = GPIO_AF1_TIM2,
		.GPIOxEchoPinAF = GPIO_AF2_TIM5,
		.TIMxTrigger = TIM2,
		.TIMxEcho = TIM5,
		.htimTrigger = &htim2,
		.htimEcho = &htim5,
		.TIMxTrigger_Channel = TIM_CHANNEL_3,
		.EchoIRQ = TIM5_IRQn,
};

// define variables for ultraSonic capture unit handlers
uint32_t LHS_firstCap = 0	, LHS_secondCap = 0,
		 RHS_firstCap = 0	, RHS_secondCap = 0,
		 FRONT_firstCap = 0	, FRONT_secondCap = 0;
uint8_t  LHS_flag = 0, RHS_flag = 0, FRONT_flag = 0;

//define variables of sensors Dat4
sensorTypeDef FRONT_sensorData 	= {1,4.00};
sensorTypeDef LHS_sensorData 	= {2,4.00};
sensorTypeDef RHS_sensorData 	= {3,4.00};
//input capture unit handlers
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
    if (htim->Instance == TIM3) {
        ultraSonicInputCaptureHandler(&htim3,&FRONT_firstCap,&FRONT_secondCap,(float*)(&FRONT_sensorData.sensorData),&FRONT_flag);
    }else if (htim->Instance == TIM4){
        ultraSonicInputCaptureHandler(&htim4,&LHS_firstCap,&LHS_secondCap,(float*)(&LHS_sensorData.sensorData),&LHS_flag);
    }else if (htim->Instance == TIM5){
        ultraSonicInputCaptureHandler(&htim5,&RHS_firstCap,&RHS_secondCap,(float*)(&RHS_sensorData.sensorData),&RHS_flag);
    }
}
void perceptionVidCheckOverFlowTask(void*pvParameters){
	for(;;){
		osDelay(1);
		uint32_t primask = __get_PRIMASK();
		__disable_irq();
		ultraSonicCheckOverFlow(&htim3,&FRONT_flag);
		ultraSonicCheckOverFlow(&htim4,&LHS_flag);
		ultraSonicCheckOverFlow(&htim5,&RHS_flag);
		__set_PRIMASK(primask);

	}
}
void perceptionVidSendSensorsDataTask(void*pvParameters){
	sensorTypeDef safeFRONT ={0}, safeLHS={0}, safeRHS={0};

	for(;;){
		osDelay(50);

		uint32_t primask = __get_PRIMASK();
		__disable_irq();

		safeFRONT = FRONT_sensorData;
		safeLHS   = LHS_sensorData;
		safeRHS   = RHS_sensorData;

		__set_PRIMASK(primask);
		communicationVidSelectSlave();
		transmissionVidSendStart();
		transmissionVidSendSensorData(&safeFRONT);
		transmissionVidSendSensorData(&safeLHS);
		transmissionVidSendSensorData(&safeRHS);
		transmissionVidSendEnd();
		communicationVidDeselectSlave();
	}
}
void perceptionVidInit(void){
	//init sensors
	ultraSonicVidInit(&LHS_ultraSonic);
	ultraSonicVidInit(&RHS_ultraSonic);
	ultraSonicVidInit(&FRONT_ultraSonic);
	//start sensing
	ultraSonicVidStart(&FRONT_ultraSonic);
	ultraSonicVidStart(&LHS_ultraSonic);
	ultraSonicVidStart(&RHS_ultraSonic);
}
void perceptionVidBegin(void){
	//define freeRTOS Tasks Parameters
	osThreadId_t checkOVFTaskHandle;
	const osThreadAttr_t checkOVFTask_attributes = {
	  .name = "OVFTask",
	  .stack_size = 128 * 4,
	  .priority = (osPriority_t) osPriorityNormal,
	};
	osThreadId_t sendDataTaskHandle;
	const osThreadAttr_t sendDataTask_attributes = {
	  .name = "sendDataTask",
	  .stack_size = 128 * 4,
	  .priority = (osPriority_t) osPriorityLow,
	};
	//create tasks
	checkOVFTaskHandle = osThreadNew(perceptionVidCheckOverFlowTask, NULL, &checkOVFTask_attributes);
	sendDataTaskHandle = osThreadNew(perceptionVidSendSensorsDataTask, NULL, &sendDataTask_attributes);

}
