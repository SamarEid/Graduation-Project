/*
 * ultraSonic.c
 *
 *  Created on: ??þ/??þ/????
 *      Author: ASHRY
 */
#include "stm32f4xx_hal.h"
#include "stm32f4xx_hal_gpio.h"
#include "stm32f4xx_hal_tim.h"
#include "./ultraSonic.h"
void ultraSonicVidInit(ultraSonicInitTypeDef* sensor) {
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    TIM_IC_InitTypeDef sConfigIC = {0};

    // === Trigger Pin Init ===
    GPIO_InitStruct.Pin = sensor->GPIOxTriggerPin;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(sensor->GPIOxTrigger, &GPIO_InitStruct);

    // ===  init Echo Pins  ===
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;

    // === Echo channel 1 Pin Init ===
    GPIO_InitStruct.Pin = sensor->GPIOx1EchoPin;
    GPIO_InitStruct.Alternate = sensor->GPIOxEchoPinAF;
    HAL_GPIO_Init(sensor->GPIOx1Echo, &GPIO_InitStruct);
    // === Echo channel 2 Pin Init ===
    GPIO_InitStruct.Pin = sensor->GPIOx2EchoPin;
    GPIO_InitStruct.Alternate = sensor->GPIOxEchoPinAF;
    HAL_GPIO_Init(sensor->GPIOx2Echo, &GPIO_InitStruct);

    // Timer Base for Echo Channels
    sensor->htimEcho->Instance = sensor->TIMxEcho;
    sensor->htimEcho->Init.Prescaler = GET_PSC();
    sensor->htimEcho->Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
    sensor->htimEcho->Init.ClockDivision = TIMER_CLOCK_DIVISON;
    sensor->htimEcho->Init.CounterMode  = TIMER_COUNTER_MODE;
    sensor->htimEcho->Init.Period = GET_ARR();
    HAL_TIM_IC_Init(sensor->htimEcho);

    // Input Capture Channel 1 Config
    sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
    sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
    sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
    sConfigIC.ICFilter = DIGITAL_FILTER;
    HAL_TIM_IC_ConfigChannel(sensor->htimEcho, &sConfigIC, ECHO_RISING_CHANNEL);
    // Input Capture Channel 1 Config
    sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_FALLING;
    HAL_TIM_IC_ConfigChannel(sensor->htimEcho, &sConfigIC, ECHO_FALLING_CHANNEL);
     //Enable interrupts
    HAL_NVIC_SetPriority(sensor->EchoIRQ, ECHO_PRIORITY, 0);
    HAL_NVIC_EnableIRQ(sensor->EchoIRQ);
}

void ultraSonicVidStart(ultraSonicInitTypeDef* sensor) {
    HAL_TIM_IC_Start_IT(sensor->htimEcho, ECHO_RISING_CHANNEL);
    HAL_TIM_IC_Start_IT(sensor->htimEcho, ECHO_FALLING_CHANNEL);
}

float ultraSonicFloatGetDistance(uint32_t* firstICVal, uint32_t* secondICVal) {
	uint32_t difference = 0;
	float distance = 4.00;
	if(*secondICVal >= *firstICVal){
		difference = (*secondICVal) - (*firstICVal);
	}else{
		difference = GET_ARR() - (*firstICVal) + (*secondICVal);
	}
	distance = (difference * SOUND_SPEED) / 2.0f; // in cm
	return distance;
}
void ultraSonicVidInputCaptureHandler(TIM_HandleTypeDef*htim, uint32_t*firstICVal, uint32_t* secondICVal,uint8_t*flag ,uint32_t ID, void*fPtr(uint32_t,float)){
	if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1 && *flag == FIRST_CAPTURE) {
		// Rising edge captured
		*firstICVal = HAL_TIM_ReadCapturedValue(htim, ECHO_RISING_CHANNEL);
		*flag = SECOND_CAPTURE;
	} else if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_2 && *flag == SECOND_CAPTURE) {
	    // Falling edge captured
		*secondICVal = HAL_TIM_ReadCapturedValue(htim, ECHO_FALLING_CHANNEL);
	    //__HAL_TIM_SET_COUNTER(htim, 0);
	    *flag = FIRST_CAPTURE;
	    float distance = ultraSonicFloatGetDistance(firstICVal, secondICVal);
	    //if (distance < MINIMUM_DISTANCE || distance > MAXIMUM_DISTANCE) return;
	     // processData
	    fPtr(ID,distance);
	}
}
void ultraSonicVidTrig(ultraSonicInitTypeDef* sensor){
	HAL_GPIO_WritePin(sensor->GPIOxTrigger, sensor->GPIOxTriggerPin, GPIO_PIN_SET);
}
void ultraSonicVidHaltTrig(ultraSonicInitTypeDef* sensor){
	HAL_GPIO_WritePin(sensor->GPIOxTrigger, sensor->GPIOxTriggerPin, GPIO_PIN_RESET);
}
void ultraSonicVidDelayMicroSeconds(uint32_t us)
{
    volatile uint32_t count = us * 16;

    while (count--)
    {
        __asm__ volatile ("nop");
    }
}
