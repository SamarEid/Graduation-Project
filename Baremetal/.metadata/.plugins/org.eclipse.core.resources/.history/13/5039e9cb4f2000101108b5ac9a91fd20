/*
 * ultraSonic.c
 *
 *  Created on: ??þ/??þ/????
 *      Author: ASHRY
 */
#include "stm32f4xx_hal.h"
#include "stm32f4xx_hal_gpio.h"
#include "stm32f4xx_hal_tim.h"
#include "./ultraSonic.h"
void ultraSonicVidInit(ultraSonicInitTypeDef* sensor) {
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    TIM_IC_InitTypeDef sConfigIC = {0};

    // === Trigger Pin Init ===
    GPIO_InitStruct.Pin = sensor->GPIOxTriggerPin;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(sensor->GPIOxTrigger, &GPIO_InitStruct);

    // ===  init Echo Pin  ===
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    GPIO_InitStruct.Pin = sensor->GPIOxEchoPin;
    GPIO_InitStruct.Alternate = sensor->GPIOxEchoPinAF;
    HAL_GPIO_Init(sensor->GPIOxEcho, &GPIO_InitStruct);


    // Timer Base for Echo Channel
    sensor->htimEcho->Instance = sensor->TIMxEcho;
    sensor->htimEcho->Init.Prescaler = GET_PSC();
    sensor->htimEcho->Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
    sensor->htimEcho->Init.ClockDivision = TIMER_CLOCK_DIVISON;
    sensor->htimEcho->Init.CounterMode  = TIMER_COUNTER_MODE;
    sensor->htimEcho->Init.Period = GET_ARR();
    HAL_TIM_IC_Init(sensor->htimEcho);

    // Input Capture Channel 1 Config
    sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
    sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
    sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
    sConfigIC.ICFilter = DIGITAL_FILTER;
    HAL_TIM_IC_ConfigChannel(sensor->htimEcho, &sConfigIC, ECHO_CHANNEL);


    //Enable interrupts
    HAL_NVIC_SetPriority(sensor->EchoIRQ, ECHO_PRIORITY, 0);
    HAL_NVIC_EnableIRQ(sensor->EchoIRQ);
}

void ultraSonicVidStart(ultraSonicInitTypeDef* sensor) {
    HAL_TIM_IC_Start_IT(sensor->htimEcho, ECHO_CHANNEL);
}

float ultraSonicFloatGetDistance(uint32_t* firstICVal, uint32_t* secondICVal) {
	uint32_t difference = 0;
	float distance = 4.00;
	if(*secondICVal >= *firstICVal){
		difference = (*secondICVal) - (*firstICVal);
	}else{
		difference = GET_ARR() - (*firstICVal) + (*secondICVal);
	}
	distance = (difference * SOUND_SPEED) / 2.0f; // in cm
	return distance;
}
void ultraSonicVidInputCaptureHandler(TIM_HandleTypeDef*htim, uint32_t*firstICVal, uint32_t* secondICVal,uint8_t*flag ,uint32_t ID, void*fPtr(uint32_t,float)){
	if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1) {
		if(*flag == FIRST_CAPTURE){
			// Rising edge captured
			*firstICVal = HAL_TIM_ReadCapturedValue(htim, ECHO_CHANNEL);
			__HAL_TIM_DISABLE_IT(htim, IT_CC_CHANNEL);
			__HAL_TIM_SET_CAPTUREPOLARITY(htim,ECHO_CHANNEL,TIM_INPUTCHANNELPOLARITY_FALLING);
			__HAL_TIM_ENABLE_IT(htim, IT_CC_CHANNEL);
			*flag = SECOND_CAPTURE;
		}else{
		    // Falling edge captured
			*secondICVal = HAL_TIM_ReadCapturedValue(htim, ECHO_CHANNEL);
			__HAL_TIM_DISABLE_IT(htim, IT_CC_CHANNEL);
			__HAL_TIM_SET_CAPTUREPOLARITY(htim,ECHO_CHANNEL,TIM_INPUTCHANNELPOLARITY_RISING);
			__HAL_TIM_ENABLE_IT(htim, IT_CC_CHANNEL);
			//__HAL_TIM_SET_COUNTER(htim, 0);
		    *flag = FIRST_CAPTURE;
		    float distance = ultraSonicFloatGetDistance(firstICVal, secondICVal);
		    //if (distance < MINIMUM_DISTANCE || distance > MAXIMUM_DISTANCE) return;
		     // processData
		    fPtr(ID,distance);
		}
	}

}
void ultraSonicVidTrig(ultraSonicInitTypeDef* sensor){
	HAL_GPIO_WritePin(sensor->GPIOxTrigger, sensor->GPIOxTriggerPin, GPIO_PIN_SET);
}
void ultraSonicVidHaltTrig(ultraSonicInitTypeDef* sensor){
	HAL_GPIO_WritePin(sensor->GPIOxTrigger, sensor->GPIOxTriggerPin, GPIO_PIN_RESET);
}
void ultraSonicVidDelayMicroSeconds(uint32_t us)
{
    volatile uint32_t count = us * 16;

    while (count--)
    {
        __asm__ volatile ("nop");
    }
}
